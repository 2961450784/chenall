<!DOCTYPE HTML>
<html><head>
<meta http-equiv="Cache-Control" content="max-age=7200" />

<!--addons at start of head-->
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>归档：2011/2 | chenall&#39;s Blog</title>
<meta name="author" content="chenall">

<meta name="description" content="chenall 的搏客,技术,分享,开源.">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="chenall&#39;s Blog"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css">
<![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link rel="author" href="https://plus.google.com/100700322385676715564" />
<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="chenall&#39;s Blog Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">

<link rel="stylesheet" href="/css/style.css" type="text/css">

<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">var site = {BASE_URI: '/'};var _js2load = [];</script>

<!--addons at end of head-->
</head>
<body>
  <!--addons at start of body-->
    <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">chenall's Blog</a>
    </div>
    <div class="collapse navbar-collapse">
      <ul class="nav navbar-nav dropdown-hover">
  
        <li item='archives/2011/02/' ><a href="/about/" title="关于">关于</a></li>      
        <li item='archives/2011/02/' class='active'><a href="/archives/" title="归档">归档</a></li>      
        <li item='archives/2011/02/' ><a href="/qzgb-fm/" title="泉州广播">泉州广播</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>在线电视<b class='caret'></b></a>
        <ul class='dropdown-menu'>
    
          <li><a href="/tv/" title="在线直播">在线直播</a></li>    
          <li><a href="http://tv1.chenall.tk" title="直播线路1">直播线路1</a></li>    
          <li><a href="http://tv2.chenall.tk" title="直播线路2">直播线路2</a></li>    
        </ul>
      </li>
    
        <li item='archives/2011/02/' ><a href="/guestbook/" title="留言板">留言板</a></li>      
        <li item='archives/2011/02/' ><a href="http://grub4dos.chenall.net" title="GRUB4DOS">GRUB4DOS</a></li>      
        <li item='archives/2011/02/' ><a href="http://almrun.chenall.net" title="ALMRUN">ALMRUN</a></li>      
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/chenall">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/chenall">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div></header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1>chenall's Blog <small>走自己的路,让别人说去吧</small></h1></div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><h2 class="archive-title">2011/2</h2>


<div class="archive">

  <ul class="list-group"><li class="list-group-item"><h3><time datetime="2011-02-25T01:41:12.000Z">2011-02-25</time>  <a href="/post/win_print_set/">[分享] 在使用批处理修改WINDOWS的打印机设置</a></h3><p class="list-group-item-text">因为无忧里面以下贴子,
http://bbs.wuyou.com/viewthread.php?tid=187450
所以就抽空研究了一下整理了一个批处理出来.
自己目前用不上,发在这里留一个底,万一自己以后碰到了就有现成的可用了.</p><li class="list-group-item"><h3><time datetime="2011-02-21T06:09:45.000Z">2011-02-21</time>  <a href="/post/linux_assembly/">[转]Linux 汇编语言开发指南</a></h3><p class="list-group-item-text">汇编语言的优点是速度快，可以直接对硬件进行操作，这对诸如图形处理等关键应用是非常重要的。Linux&nbsp;是一个用&nbsp;C&nbsp;语言开发的操作系统，这使得很多程序员开始忘记在&nbsp;Linux&nbsp;中还可以直接使用汇编这一底层语言来优化程序的性能。本文为那些在Linux&nbsp;平台上编写汇编代码的程序员提供指南，介绍&nbsp;Linux&nbsp;汇编语言的语法格式和开发工具，并辅以具体的例子讲述如何开发实用的Linux&nbsp;汇编程序。一、简介作为最基本的编程语言之一，汇编语言虽然应用的范围不算很广，但重要性却勿庸置疑，因为它能够完成许多其它语言所无法完成的功能。就拿&nbsp;Linux&nbsp;内核来讲，虽然绝大部分代码是用&nbsp;C&nbsp;语言编写的，但仍然不可避免地在某些关键地方使用了汇编代码，其中主要是在&nbsp;Linux&nbsp;的启动部分。由于这部分代码与硬件的关系非常密切，即使是&nbsp;C&nbsp;语言也会有些力不从心，而汇编语言则能够很好扬长避短，最大限度地发挥硬件的性能。大多数情况下&nbsp;Linux&nbsp;程序员不需要使用汇编语言，因为即便是硬件驱动这样的底层程序在&nbsp;Linux&nbsp;操作系统中也可以用完全用&nbsp;C&nbsp;语言来实现，再加上&nbsp;GCC&nbsp;这一优秀的编译器目前已经能够对最终生成的代码进行很好的优化，的确有足够的理由让我们可以暂时将汇编语言抛在一边了。但实现情况是&nbsp;Linux&nbsp;程序员有时还是需要使用汇编，或者不得不使用汇编，理由很简单：精简、高效和&nbsp;libc&nbsp;无关性。假设要移植&nbsp;Linux&nbsp;到某一特定的嵌入式硬件环境下，首先必然面临如何减少系统大小、提高执行效率等问题，此时或许只有汇编语言能帮上忙了。汇编语言直接同计算机的底层软件甚至硬件进行交互，它具有如下一些优点：·&nbsp;能够直接访问与硬件相关的存储器或&nbsp;I/O&nbsp;端口；·&nbsp;能够不受编译器的限制，对生成的二进制代码进行完全的控制；·&nbsp;能够对关键代码进行更准确的控制，避免因线程共同访问或者硬件设备共享引起的死锁；·&nbsp;能够根据特定的应用对代码做最佳的优化，提高运行速度；·&nbsp;能够最大限度地发挥硬件的功能。同时还应该认识到，汇编语言是一种层次非常低的语言，它仅仅高于直接手工编写二进制的机器指令码，因此不可避免地存在一些缺点：·&nbsp;编写的代码非常难懂，不好维护；·&nbsp;很容易产生&nbsp;bug，难于调试；·&nbsp;只能针对特定的体系结构和处理器进行优化；·&nbsp;开发效率很低，时间长且单调。Linux&nbsp;下用汇编语言编写的代码具有两种不同的形式。第一种是完全的汇编代码，指的是整个程序全部用汇编语言编写。尽管是完全的汇编代码，Linux&nbsp;平台下的汇编工具也吸收了&nbsp;C&nbsp;语言的长处，使得程序员可以使用&nbsp;#include、#ifdef&nbsp;等预处理指令，并能够通过宏定义来简化代码。第二种是内嵌的汇编代码，指的是可以嵌入到C语言程序中的汇编代码片段。虽然&nbsp;ANSI&nbsp;的&nbsp;C&nbsp;语言标准中没有关于内嵌汇编代码的相应规定，但各种实际使用的&nbsp;C&nbsp;编译器都做了这方面的扩充，这其中当然就包括&nbsp;Linux&nbsp;平台下的&nbsp;GCC。二、Linux&nbsp;汇编语法格式绝大多数&nbsp;Linux&nbsp;程序员以前只接触过DOS/Windows&nbsp;下的汇编语言，这些汇编代码都是&nbsp;Intel&nbsp;风格的。但在&nbsp;Unix&nbsp;和&nbsp;Linux&nbsp;系统中，更多采用的还是&nbsp;AT&amp;T&nbsp;格式，两者在语法格式上有着很大的不同：在&nbsp;AT&amp;T&nbsp;汇编格式中，寄存器名要加上&nbsp;‘%’&nbsp;作为前缀；而在&nbsp;Intel&nbsp;汇编格式中，寄存器名不需要加前缀。例如：AT&amp;T&nbsp;格式Intel&nbsp;格式pushl&nbsp;%eaxpush&nbsp;eax在&nbsp;AT&amp;T&nbsp;汇编格式中，用&nbsp;‘$’&nbsp;前缀表示一个立即操作数；而在&nbsp;Intel&nbsp;汇编格式中，立即数的表示不用带任何前缀。例如：AT&amp;T&nbsp;格式Intel&nbsp;格式pushl&nbsp;$1push&nbsp;1AT&amp;T&nbsp;和&nbsp;Intel&nbsp;格式中的源操作数和目标操作数的位置正好相反。在&nbsp;Intel&nbsp;汇编格式中，目标操作数在源操作数的左边；而在&nbsp;AT&amp;T&nbsp;汇编格式中，目标操作数在源操作数的右边。例如：AT&amp;T&nbsp;格式Intel&nbsp;格式addl&nbsp;$1,&nbsp;%eaxadd&nbsp;eax,&nbsp;1在&nbsp;AT&amp;T&nbsp;汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀‘b’、‘w’、‘l’分别表示操作数为字节（byte，8&nbsp;比特）、字（word，16&nbsp;比特）和长字（long，32比特）；而在&nbsp;Intel&nbsp;汇编格式中，操作数的字长是用&nbsp;“byte&nbsp;ptr”&nbsp;和&nbsp;“word&nbsp;ptr”&nbsp;等前缀来表示的。例如：AT&amp;T&nbsp;格式Intel&nbsp;格式movb&nbsp;val,&nbsp;%almov&nbsp;al,&nbsp;byte&nbsp;ptr&nbsp;val在&nbsp;AT&amp;T&nbsp;汇编格式中，绝对转移和调用指令（jump/call）的操作数前要加上‘*’作为前缀，而在&nbsp;Intel&nbsp;格式中则不需要。远程转移指令和远程子调用指令的操作码，在&nbsp;AT&amp;T&nbsp;汇编格式中为&nbsp;“ljump”&nbsp;和&nbsp;“lcall”，而在&nbsp;Intel&nbsp;汇编格式中则为&nbsp;“jmp&nbsp;far”&nbsp;和&nbsp;“call&nbsp;far”，即：AT&amp;T&nbsp;格式Intel&nbsp;格式ljump&nbsp;$section,&nbsp;$offsetjmp&nbsp;far&nbsp;section:offsetlcall&nbsp;$section,&nbsp;$offsetcall&nbsp;far&nbsp;section:offset与之相应的远程返回指令则为：AT&amp;T&nbsp;格式Intel&nbsp;格式lret&nbsp;$stack_adjustret&nbsp;far&nbsp;stack_adjust在&nbsp;AT&amp;T&nbsp;汇编格式中，内存操作数的寻址方式是section:disp(base,&nbsp;index,&nbsp;scale)而在&nbsp;Intel&nbsp;汇编格式中，内存操作数的寻址方式为：section:[base&nbsp;+&nbsp;index*scale&nbsp;+&nbsp;disp]由于&nbsp;Linux&nbsp;工作在保护模式下，用的是&nbsp;32&nbsp;位线性地址，所以在计算地址时不用考虑段基址和偏移量，而是采用如下的地址计算方法：disp&nbsp;+&nbsp;base&nbsp;+&nbsp;index&nbsp;*&nbsp;scale下面是一些内存操作数的例子：AT&amp;T&nbsp;格式Intel&nbsp;格式movl&nbsp;-4(%ebp),&nbsp;%eaxmov&nbsp;eax,&nbsp;[ebp&nbsp;-&nbsp;4]movl&nbsp;array(,&nbsp;%eax,&nbsp;4),&nbsp;%eaxmov&nbsp;eax,&nbsp;[eax*4&nbsp;+&nbsp;array]movw&nbsp;array(%ebx,&nbsp;%eax,&nbsp;4),&nbsp;%cxmov&nbsp;cx,&nbsp;[ebx&nbsp;+&nbsp;4*eax&nbsp;+&nbsp;array]movb&nbsp;$4,&nbsp;%fs:(%eax)mov&nbsp;fs:eax,&nbsp;4三、Hello&nbsp;World!真不知道打破这个传统会带来什么样的后果，但既然所有程序设计语言的第一个例子都是在屏幕上打印一个字符串&nbsp;“Hello&nbsp;World!”，那我们也以这种方式来开始介绍&nbsp;Linux&nbsp;下的汇编语言程序设计。在&nbsp;Linux&nbsp;操作系统中，你有很多办法可以实现在屏幕上显示一个字符串，但最简洁的方式是使用&nbsp;Linux&nbsp;内核提供的系统调用。使用这种方法最大的好处是可以直接和操作系统的内核进行通讯，不需要链接诸如&nbsp;libc&nbsp;这样的函数库，也不需要使用&nbsp;ELF&nbsp;解释器，因而代码尺寸小且执行速度快。Linux&nbsp;是一个运行在保护模式下的&nbsp;32&nbsp;位操作系统，采用&nbsp;flat&nbsp;memory&nbsp;模式，目前最常用到的是&nbsp;ELF&nbsp;格式的二进制代码。一个&nbsp;ELF&nbsp;格式的可执行程序通常划分为如下几个部分：.text、.data&nbsp;和&nbsp;.bss，其中&nbsp;.text&nbsp;是只读的代码区，.data&nbsp;是可读可写的数据区，而&nbsp;.bss&nbsp;则是可读可写且没有初始化的数据区。代码区和数据区在&nbsp;ELF&nbsp;中统称为&nbsp;section，根据实际需要你可以使用其它标准的&nbsp;section，也可以添加自定义&nbsp;section，但一个&nbsp;ELF&nbsp;可执行程序至少应该有一个&nbsp;.text&nbsp;部分。下面给出我们的第一个汇编程序，用的是&nbsp;AT&amp;T&nbsp;汇编语言格式：例1.&nbsp;AT&amp;T&nbsp;格式#hello.s&nbsp;.data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;数据段声明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg&nbsp;:&nbsp;.string&nbsp;”Hello,&nbsp;world!\\n”&nbsp;#&nbsp;要输出的字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;=&nbsp;.&nbsp;-&nbsp;msg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;字串长度.text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;代码段声明.global&nbsp;_start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;指定入口函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_start:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;在屏幕上显示一个字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;$len,&nbsp;%edx&nbsp;&nbsp;#&nbsp;参数三：字符串长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;$msg,&nbsp;%ecx&nbsp;&nbsp;#&nbsp;参数二：要显示的字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;$1,&nbsp;%ebx&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;参数一：文件描述符(stdout)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;$4,&nbsp;%eax&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;系统调用号(sys_write)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;$0×80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;调用内核功能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;退出程序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;$0,%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;参数一：退出代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;$1,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;系统调用号(sys_exit)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;$0×80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;调用内核功能初次接触到&nbsp;AT&amp;T&nbsp;格式的汇编代码时，很多程序员都认为太晦涩难懂了，没有关系，在&nbsp;Linux&nbsp;平台上你同样可以使用&nbsp;Intel&nbsp;格式来编写汇编程序：例2.&nbsp;Intel&nbsp;格式;&nbsp;hello.asm&nbsp;section&nbsp;.data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;数据段声明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg&nbsp;db&nbsp;”Hello,&nbsp;world!”,&nbsp;0xA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;要输出的字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;equ&nbsp;$&nbsp;-&nbsp;msg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;字串长度section&nbsp;.text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;代码段声明global&nbsp;_start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;指定入口函数_start:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;在屏幕上显示一个字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;edx,&nbsp;len&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;参数三：字符串长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ecx,&nbsp;msg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;参数二：要显示的字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ebx,&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;参数一：文件描述符(stdout)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;系统调用号(sys_write)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;0×80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;调用内核功能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;退出程序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ebx,&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;参数一：退出代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;系统调用号(sys_exit)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;0×80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;调用内核功能上面两个汇编程序采用的语法虽然完全不同，但功能却都是调用&nbsp;Linux&nbsp;内核提供的&nbsp;sys_write&nbsp;来显示一个字符串，然后再调用&nbsp;sys_exit&nbsp;退出程序。在&nbsp;Linux&nbsp;内核源文件&nbsp;include/asm-i386/unistd.h&nbsp;中，可以找到所有系统调用的定义。四、Linux&nbsp;汇编工具Linux&nbsp;平台下的汇编工具虽然种类很多，但同&nbsp;DOS/Windows&nbsp;一样，最基本的仍然是汇编器、连接器和调试器。1.汇编器汇编器（assembler）的作用是将用汇编语言编写的源程序转换成二进制形式的目标代码。Linux&nbsp;平台的标准汇编器是&nbsp;GAS，它是&nbsp;GCC&nbsp;所依赖的后台汇编工具，通常包含在&nbsp;binutils&nbsp;软件包中。GAS&nbsp;使用标准的&nbsp;AT&amp;T&nbsp;汇编语法，可以用来汇编用&nbsp;AT&amp;T&nbsp;格式编写的程序：[xiaowp@gary&nbsp;code]$&nbsp;as&nbsp;-o&nbsp;hello.o&nbsp;hello.sLinux&nbsp;平台上另一个经常用到的汇编器是&nbsp;NASM，它提供了很好的宏指令功能，并能够支持相当多的目标代码格式，包括&nbsp;bin、a.out、coff、elf、rdf&nbsp;等。NASM&nbsp;采用的是人工编写的语法分析器，因而执行速度要比&nbsp;GAS&nbsp;快很多，更重要的是它使用的是&nbsp;Intel&nbsp;汇编语法，可以用来编译用&nbsp;Intel&nbsp;语法格式编写的汇编程序：[xiaowp@gary&nbsp;code]$&nbsp;nasm&nbsp;-f&nbsp;elf&nbsp;hello.asm2.链接器由汇编器产生的目标代码是不能直接在计算机上运行的，它必须经过链接器的处理才能生成可执行代码。链接器通常用来将多个目标代码连接成一个可执行代码，这样可以先将整个程序分成几个模块来单独开发，然后才将它们组合(链接)成一个应用程序。&nbsp;Linux&nbsp;使用&nbsp;ld&nbsp;作为标准的链接程序，它同样也包含在&nbsp;binutils&nbsp;软件包中。汇编程序在成功通过&nbsp;GAS&nbsp;或&nbsp;NASM&nbsp;的编译并生成目标代码后，就可以使用&nbsp;ld&nbsp;将其链接成可执行程序了：[xiaowp@gary&nbsp;code]$&nbsp;ld&nbsp;-s&nbsp;-o&nbsp;hello&nbsp;hello.o3.调试器有人说程序不是编出来而是调出来的，足见调试在软件开发中的重要作用，在用汇编语言编写程序时尤其如此。Linux&nbsp;下调试汇编代码既可以用&nbsp;GDB、DDD&nbsp;这类通用的调试器，也可以使用专门用来调试汇编代码的&nbsp;ALD(Assembly&nbsp;Language&nbsp;Debugger)。从调试的角度来看，使用&nbsp;GAS&nbsp;的好处是可以在生成的目标代码中包含符号表(symbol&nbsp;table)，这样就可以使用&nbsp;GDB&nbsp;和&nbsp;DDD&nbsp;来进行源码级的调试了。要在生成的可执行程序中包含符号表，可以采用下面的方式进行编译和链接：[xiaowp@gary&nbsp;code]$&nbsp;as&nbsp;–gstabs&nbsp;-o&nbsp;hello.o&nbsp;hello.s[xiaowp@gary&nbsp;code]$&nbsp;ld&nbsp;-o&nbsp;hello&nbsp;hello.o执行&nbsp;as&nbsp;命令时带上参数&nbsp;–gstabs&nbsp;可以告诉汇编器在生成的目标代码中加上符号表，同时需要注意的是，在用&nbsp;ld&nbsp;命令进行链接时不要加上&nbsp;-s&nbsp;参数，否则目标代码中的符号表在链接时将被删去。在&nbsp;GDB&nbsp;和&nbsp;DDD&nbsp;中调试汇编代码和调试&nbsp;C&nbsp;语言代码是一样的，你可以通过设置断点来中断程序的运行，查看变量和寄存器的当前值，并可以对代码进行单步跟踪。图1&nbsp;是在&nbsp;DDD&nbsp;中调试汇编代码时的情景：图1&nbsp;用&nbsp;DDD&nbsp;中调试汇编程序汇编程序员通常面对的都是一些比较苛刻的软硬件环境，短小精悍的ALD可能更能符合实际的需要，因此下面主要介绍一下如何用ALD来调试汇编程序。首先在命令行方式下执行ald命令来启动调试器，该命令的参数是将要被调试的可执行程序：[xiaowp@gary&nbsp;doc]$&nbsp;ald&nbsp;helloAssembly&nbsp;Language&nbsp;Debugger&nbsp;0.1.3Copyright&nbsp;(C)&nbsp;2000-2002&nbsp;Patrick&nbsp;Alkenhello:&nbsp;ELF&nbsp;Intel&nbsp;80386&nbsp;(32&nbsp;bit),&nbsp;LSB,&nbsp;Executable,&nbsp;Version&nbsp;1&nbsp;(current)Loading&nbsp;debugging&nbsp;symbols…(15&nbsp;symbols&nbsp;loaded)ald&gt;当&nbsp;ALD&nbsp;的提示符出现之后，用&nbsp;disassemble&nbsp;命令对代码段进行反汇编：ald&gt;&nbsp;disassemble&nbsp;-s&nbsp;.textDisassembling&nbsp;section&nbsp;.text&nbsp;(0×08048074&nbsp;-&nbsp;0×08048096)08048074&nbsp;&nbsp;BA0F000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;edx,&nbsp;0xf08048079&nbsp;&nbsp;B998900408&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ecx,&nbsp;0×80490980804807E&nbsp;&nbsp;BB01000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ebx,&nbsp;0×108048083&nbsp;&nbsp;B804000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;0×408048088&nbsp;&nbsp;CD80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;0×800804808A&nbsp;&nbsp;BB00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ebx,&nbsp;0×00804808F&nbsp;&nbsp;B801000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;0×108048094&nbsp;&nbsp;CD80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;0×80上述输出信息的第一列是指令对应的地址码，利用它可以设置在程序执行时的断点：ald&gt;&nbsp;break&nbsp;0×08048088Breakpoint&nbsp;1&nbsp;set&nbsp;for&nbsp;0×08048088断点设置好后，使用&nbsp;run&nbsp;命令开始执行程序。ALD&nbsp;在遇到断点时将自动暂停程序的运行，同时会显示所有寄存器的当前值：ald&gt;&nbsp;runStarting&nbsp;program:&nbsp;helloBreakpoint&nbsp;1&nbsp;encountered&nbsp;at&nbsp;0×08048088eax&nbsp;=&nbsp;0×00000004&nbsp;ebx&nbsp;=&nbsp;0×00000001&nbsp;ecx&nbsp;=&nbsp;0×08049098&nbsp;edx&nbsp;=&nbsp;0x0000000Fesp&nbsp;=&nbsp;0xBFFFF6C0&nbsp;ebp&nbsp;=&nbsp;0×00000000&nbsp;esi&nbsp;=&nbsp;0×00000000&nbsp;edi&nbsp;=&nbsp;0×00000000ds&nbsp;&nbsp;=&nbsp;0x0000002B&nbsp;es&nbsp;&nbsp;=&nbsp;0x0000002B&nbsp;fs&nbsp;&nbsp;=&nbsp;0×00000000&nbsp;gs&nbsp;&nbsp;=&nbsp;0×00000000ss&nbsp;&nbsp;=&nbsp;0x0000002B&nbsp;cs&nbsp;&nbsp;=&nbsp;0×00000023&nbsp;eip&nbsp;=&nbsp;0×08048088&nbsp;eflags&nbsp;=&nbsp;0×00000246Flags:&nbsp;PF&nbsp;ZF&nbsp;IF08048088&nbsp;&nbsp;CD80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;0×80如果需要对汇编代码进行单步调试，可以使用&nbsp;next&nbsp;命令：ald&gt;&nbsp;nextHello,&nbsp;world!eax&nbsp;=&nbsp;0x0000000F&nbsp;ebx&nbsp;=&nbsp;0×00000000&nbsp;ecx&nbsp;=&nbsp;0×08049098&nbsp;edx&nbsp;=&nbsp;0x0000000Fesp&nbsp;=&nbsp;0xBFFFF6C0&nbsp;ebp&nbsp;=&nbsp;0×00000000&nbsp;esi&nbsp;=&nbsp;0×00000000&nbsp;edi&nbsp;=&nbsp;0×00000000ds&nbsp;&nbsp;=&nbsp;0x0000002B&nbsp;es&nbsp;&nbsp;=&nbsp;0x0000002B&nbsp;fs&nbsp;&nbsp;=&nbsp;0×00000000&nbsp;gs&nbsp;&nbsp;=&nbsp;0×00000000ss&nbsp;&nbsp;=&nbsp;0x0000002B&nbsp;cs&nbsp;&nbsp;=&nbsp;0×00000023&nbsp;eip&nbsp;=&nbsp;0x0804808F&nbsp;eflags&nbsp;=&nbsp;0×00000346Flags:&nbsp;PF&nbsp;ZF&nbsp;TF&nbsp;IF0804808F&nbsp;&nbsp;B801000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;0×1若想获得&nbsp;ALD&nbsp;支持的所有调试命令的详细列表，可以使用&nbsp;help&nbsp;命令：ald&gt;&nbsp;helpCommands&nbsp;may&nbsp;be&nbsp;abbreviated.If&nbsp;a&nbsp;blank&nbsp;command&nbsp;is&nbsp;entered,&nbsp;the&nbsp;last&nbsp;command&nbsp;is&nbsp;repeated.Type&nbsp;`help&nbsp;&lt;command&gt;’&nbsp;for&nbsp;more&nbsp;specific&nbsp;information&nbsp;on&nbsp;&lt;command&gt;.General&nbsp;commandsattach&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clear&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detach&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disassembleenter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;examine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;help&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadnext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setstep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unload&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeBreakpoint&nbsp;related&nbsp;commandsbreak&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ignorelbreak&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbreak五、系统调用即便是最简单的汇编程序，也难免要用到诸如输入、输出以及退出等操作，而要进行这些操作则需要调用操作系统所提供的服务，也就是系统调用。除非你的程序只完成加减乘除等数学运算，否则将很难避免使用系统调用，事实上除了系统调用不同之外，各种操作系统的汇编编程往往都是很类似的。在&nbsp;Linux&nbsp;平台下有两种方式来使用系统调用：利用封装后的&nbsp;C&nbsp;库（libc）或者通过汇编直接调用。其中通过汇编语言来直接调用系统调用，是最高效地使用&nbsp;Linux&nbsp;内核服务的方法，因为最终生成的程序不需要与任何库进行链接，而是直接和内核通信。和&nbsp;DOS&nbsp;一样，Linux&nbsp;下的系统调用也是通过中断（int&nbsp;0×80）来实现的。在执行&nbsp;int&nbsp;80&nbsp;指令时，寄存器&nbsp;eax&nbsp;中存放的是系统调用的功能号，而传给系统调用的参数则必须按顺序放到寄存器&nbsp;ebx，ecx，edx，esi，edi&nbsp;中，当系统调用完成之后，返回值可以在寄存器&nbsp;eax&nbsp;中获得。所有的系统调用功能号都可以在文件&nbsp;/usr/include/bits/syscall.h&nbsp;中找到，为了便于使用，它们是用&nbsp;SYS_&lt;name&gt;&nbsp;这样的宏来定义的，如&nbsp;SYS_write、SYS_exit&nbsp;等。例如，经常用到的&nbsp;write&nbsp;函数是如下定义的：ssize_t&nbsp;write(int&nbsp;fd,&nbsp;const&nbsp;void&nbsp;*buf,&nbsp;size_t&nbsp;count);该函数的功能最终是通过&nbsp;SYS_write&nbsp;这一系统调用来实现的。根据上面的约定，参数&nbsp;fb、buf&nbsp;和&nbsp;count&nbsp;分别存在寄存器&nbsp;ebx、ecx&nbsp;和&nbsp;edx&nbsp;中，而系统调用号&nbsp;SYS_write&nbsp;则放在寄存器&nbsp;eax&nbsp;中，当&nbsp;int&nbsp;0×80&nbsp;指令执行完毕后，返回值可以从寄存器&nbsp;eax&nbsp;中获得。或许你已经发现，在进行系统调用时至多只有&nbsp;5&nbsp;个寄存器能够用来保存参数，难道所有系统调用的参数个数都不超过&nbsp;5&nbsp;吗？当然不是，例如&nbsp;mmap&nbsp;函数就有&nbsp;6&nbsp;个参数，这些参数最后都需要传递给系统调用&nbsp;SYS_mmap：void&nbsp;&nbsp;*&nbsp;&nbsp;mmap(void&nbsp;*start,&nbsp;size_t&nbsp;length,&nbsp;int&nbsp;prot&nbsp;,&nbsp;int&nbsp;flags,&nbsp;int&nbsp;fd,&nbsp;off_t&nbsp;offset);当一个系统调用所需的参数个数大于&nbsp;5&nbsp;时，执行int&nbsp;0×80&nbsp;指令时仍需将系统调用功能号保存在寄存器&nbsp;eax&nbsp;中，所不同的只是全部参数应该依次放在一块连续的内存区域里，同时在寄存器&nbsp;ebx&nbsp;中保存指向该内存区域的指针。系统调用完成之后，返回值仍将保存在寄存器&nbsp;eax&nbsp;中。由于只是需要一块连续的内存区域来保存系统调用的参数，因此完全可以像普通的函数调用一样使用栈(stack)来传递系统调用所需的参数。但要注意一点，Linux&nbsp;采用的是&nbsp;C&nbsp;语言的调用模式，这就意味着所有参数必须以相反的顺序进栈，即最后一个参数先入栈，而第一个参数则最后入栈。如果采用栈来传递系统调用所需的参数，在执行int&nbsp;0×80&nbsp;指令时还应该将栈指针的当前值复制到寄存器&nbsp;ebx中。六、命令行参数在&nbsp;Linux&nbsp;操作系统中，当一个可执行程序通过命令行启动时，其所需的参数将被保存到栈中：首先是&nbsp;argc，然后是指向各个命令行参数的指针数组&nbsp;argv，最后是指向环境变量的指针数据&nbsp;envp。在编写汇编语言程序时，很多时候需要对这些参数进行处理，下面的代码示范了如何在汇编代码中进行命令行参数的处理：例3.&nbsp;处理命令行参数#&nbsp;args.s//有些不明白.text.globl&nbsp;_start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_start:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;popl&nbsp;&nbsp;&nbsp;&nbsp;%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;argcvnext:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;popl&nbsp;&nbsp;&nbsp;&nbsp;%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;argv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;%ecx,&nbsp;%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;空指针表明结束&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jz&nbsp;&nbsp;exit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;%ecx,&nbsp;%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xorl&nbsp;&nbsp;&nbsp;&nbsp;%edx,&nbsp;%edxstrlen:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movb&nbsp;&nbsp;&nbsp;&nbsp;(%ebx),&nbsp;%al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc&nbsp;%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc&nbsp;%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;%al,&nbsp;%al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jnz&nbsp;strlen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movb&nbsp;&nbsp;&nbsp;&nbsp;$10,&nbsp;-1(%ebx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;$4,&nbsp;%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;系统调用号(sys_write)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;$1,&nbsp;%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;文件描述符(stdout)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;$0×80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;vnextexit:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;$1,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;系统调用号(sys_exit)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xorl&nbsp;&nbsp;&nbsp;&nbsp;%ebx,&nbsp;%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;退出代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$0×80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret七、GCC&nbsp;内联汇编用汇编编写的程序虽然运行速度快，但开发速度非常慢，效率也很低。如果只是想对关键代码段进行优化，或许更好的办法是将汇编指令嵌入到&nbsp;C&nbsp;语言程序中，从而充分利用高级语言和汇编语言各自的特点。但一般来讲，在&nbsp;C&nbsp;代码中嵌入汇编语句要比“纯粹“的汇编语言代码复杂得多，因为需要解决如何分配寄存器，以及如何与C代码中的变量相结合等问题。GCC&nbsp;提供了很好的内联汇编支持，最基本的格式是：__asm__(“asm&nbsp;statements”);例如：__asm__(“nop”);&nbsp;如果需要同时执行多条汇编语句，则应该用“\\n\\t”将各个语句分隔开，例如：__asm__(&nbsp;”pushl&nbsp;%%eax&nbsp;\\n\\t”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”movl&nbsp;$0,&nbsp;%%eax&nbsp;\\n\\t”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”popl&nbsp;%eax”);通常嵌入到&nbsp;C&nbsp;代码中的汇编语句很难做到与其它部分没有任何关系，因此更多时候需要用到完整的内联汇编格式：__asm__(“asm&nbsp;statements”&nbsp;:&nbsp;outputs&nbsp;:&nbsp;inputs&nbsp;:&nbsp;registers-modified);插入到&nbsp;C&nbsp;代码中的汇编语句是以“:”分隔的四个部分，其中第一部分就是汇编代码本身，通常称为指令部，其格式和在汇编语言中使用的格式基本相同。指令部分是必须的，而其它部分则可以根据实际情况而省略。在将汇编语句嵌入到C代码中时，操作数如何与C代码中的变量相结合是个很大的问题。GCC采用如下方法来解决这个问题：程序员提供具体的指令，而对寄存器的使用则只需给出“样板“和约束条件就可以了，具体如何将寄存器与变量结合起来完全由GCC和GAS来负责。在GCC内联汇编语句的指令部中，加上前缀‘%’的数字(如%0，%1)表示的就是需要使用寄存器的“样板“操作数。指令部中使用了几个样板操作数，就表明有几个变量需要与寄存器相结合，这样GCC和GAS在编译和汇编时会根据后面给定的约束条件进行恰当的处理。由于样板操作数也使用‘%’作为前缀，因此在涉及到具体的寄存器时，寄存器名前面应该加上两个‘%’，以免产生混淆。紧跟在指令部后面的是输出部，是规定输出变量如何与样板操作数进行结合的条件，每个条件称为一个“约束“，必要时可以包含多个约束，相互之间用逗号分隔开就可以了。每个输出约束都以‘=’号开始，然后紧跟一个对操作数类型进行说明的字后，最后是如何与变量相结合的约束。凡是与输出部中说明的操作数相结合的寄存器或操作数本身，在执行完嵌入的汇编代码后均不保留执行之前的内容，这是GCC在调度寄存器时所使用的依据。输出部后面是输入部，输入约束的格式和输出约束相似，但不带‘=’号。如果一个输入约束要求使用寄存器，则GCC在预处理时就会为之分配一个寄存器，并插入必要的指令将操作数装入该寄存器。与输入部中说明的操作数结合的寄存器或操作数本身，在执行完嵌入的汇编代码后也不保留执行之前的内容。有时在进行某些操作时，除了要用到进行数据输入和输出的寄存器外，还要使用多个寄存器来保存中间计算结果，这样就难免会破坏原有寄存器的内容。在GCC内联汇编格式中的最后一个部分中，可以对将产生副作用的寄存器进行说明，以便GCC能够采用相应的措施。下面是一个内联汇编的简单例子：例4.内联汇编/*&nbsp;inline.c&nbsp;*/int&nbsp;main(){&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;10,&nbsp;b&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;__asm__&nbsp;__volatile__(“movl&nbsp;%1,&nbsp;%%eax;\\n\\r”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”movl&nbsp;%%eax,&nbsp;%0;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:”=r”(b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;输出&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:”r”(a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;输入&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:”%eax”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;受影响的寄存器&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(“Result:&nbsp;%d,&nbsp;%d\\n”,&nbsp;a,&nbsp;b);}上面的程序完成将变量a的值赋予变量b，有几点需要说明：·&nbsp;变量b是输出操作数，通过%0来引用，而变量a是输入操作数，通过%1来引用。·&nbsp;输入操作数和输出操作数都使用r进行约束，表示将变量a和变量b存储在寄存器中。输入约束和输出约束的不同点在于输出约束多一个约束修饰符‘=’。·&nbsp;在内联汇编语句中使用寄存器eax时，寄存器名前应该加两个‘%’，即%%eax。内联汇编中使用%0、%1等来标识变量，任何只带一个‘%’的标识符都看成是操作数，而不是寄存器。·&nbsp;内联汇编语句的最后一个部分告诉GCC它将改变寄存器eax中的值，GCC在处理时不应使用该寄存器来存储任何其它的值。·&nbsp;由于变量b被指定成输出操作数，当内联汇编语句执行完毕后，它所保存的值将被更新。在内联汇编中用到的操作数从输出部的第一个约束开始编号，序号从0开始，每个约束记数一次，指令部要引用这些操作数时，只需在序号前加上‘%’作为前缀就可以了。需要注意的是，内联汇编语句的指令部在引用一个操作数时总是将其作为32位的长字使用，但实际情况可能需要的是字或字节，因此应该在约束中指明正确的限定符：限定符意义“m”、“v”、“o”内存单元“r”任何寄存器“q”寄存器eax、ebx、ecx、edx之一“i”、“h”直接操作数“E”和“F”浮点数“g”任意“a”、“b”、“c”、“d”分别表示寄存器eax、ebx、ecx和edx“S”和“D”寄存器esi、edi“I”常数（0至31）&nbsp;1。”m”:操作数是内存变量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2。”o”:操作数是内存变量，但它的寻址方式必须是“偏移量”类型的，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是基址寻址或者基址加变址寻址。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3。”V”:操作数是内存变量，其寻址方式非“偏移量”类型。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4。”&nbsp;&nbsp;&nbsp;”:操作数是内存变量，其地址自动增量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6。”r”:操作数是通用寄存器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7。”i”:操作数是立即操作数。（其值可在汇编时确定）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8。”n”:操作数是立即操作数。有些系统不支持除字(双字节)以外的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;立即操作数，这些操作数要用”n”而不是”i”来描述。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9。”g”:操作数可以是立即数，内存变量或者寄存器，只要寄存器属&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于通用寄存器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10。”X”:操作数允许是任何类型。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11。”0″,”1″,…,”9″:操作数与某个指定的操作数匹配。也就是说，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该操作数就是指定的那个操作数。例如，如果用”0″来描述”%1″操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数，那么”%1″引用的其实就是”%0″操作数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12。”p”:操作数是一个合法的内存地址（指针）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13。”=”:操作数在指令中是只写的（输出操作数）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14。”+”:操作数在指令中是读-写类型的（输入-输出操作数）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15。”a”:寄存器EAX。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16。”b”:寄存器EBX。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17。”c”:寄存器ECX。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18。”d”:寄存器EDX。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19。”q”:寄存器”a”,”b”,”c”或者”d”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20。”A”:寄存器”a”或者”d”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;21。”a”:寄存器EAX。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22。”f”:浮点数寄存器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;23。”t”:第一个浮点数寄存器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24。”u”:第二个浮点数寄存器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25。”D”:寄存器di。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;26。”S”:寄存器si。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;27。”I”:0-31之间的立即数。（用于32位的移位指令）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28。”J”:0-63之间的立即数。（用于64位的移位指令）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;29。”N”:0-255之间的立即数。(用于”out”指令）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30。”G”:标准的80387浮点常数。&nbsp;&nbsp;&nbsp;&nbsp;八、小结Linux操作系统是用C语言编写的，汇编只在必要的时候才被人们想到，但它却是减少代码尺寸和优化代码性能的一种非常重要的手段，特别是在与硬件直接交互的时候，汇编可以说是最佳的选择。Linux提供了非常优秀的工具来支持汇编程序的开发，使用GCC的内联汇编能够充分地发挥C语言和汇编语言各自的优点。参考资料1&nbsp;在网站&nbsp;http://linuxassembly.org上可以找到大量的Linux汇编资源。2&nbsp;软件包binutils提供了as和ld等实用工具，其相关信息可以在网站&nbsp;http://sources.redhat.com/binutils/上找到。3&nbsp;NASM是Intel格式的汇编器，其相关信息可以在网站&nbsp;http://nasm.sourceforge.net上找到。4&nbsp;ALD是一个短小精悍的汇编调试器，其相关信息可以在网站&nbsp;http://dunx1.irt.drexel.edu/~psa22/ald.html上找到。5&nbsp;intel2gas是一个能够将Intel汇编格式转换成AT&amp;T汇编格式的小工具，其相关信息可以在网站&nbsp;http://www.niksula.cs.hut.fi/~mtiihone/intel2gas/上找到。6&nbsp;IBM&nbsp;developerWorks上有一篇介绍GCC内联汇编的文章(&nbsp;http://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/index.shtml)。7&nbsp;本文代码下载：&nbsp;代码。GAS中每个操作都是有一个字符的后缀，表明操作数的大小。C声明GAS后缀大小(字节)charb1shortw2(unsigned)&nbsp;int&nbsp;/&nbsp;long&nbsp;/&nbsp;char*l4floats4doublel8long&nbsp;doublet10/12注意：GAL使用后缀“l”同时表示4字节整数和8字节双精度浮点数，这不会产生歧义因为浮点数使用的是完全不同的指令和寄存器。操作数格式：格式操作数值名称样例（GAS&nbsp;=&nbsp;C语言）$ImmImm立即数寻址$1&nbsp;=&nbsp;1EaR[Ea]寄存器寻址%eax&nbsp;=&nbsp;eaxImmM[Imm]绝对寻址0×104&nbsp;=&nbsp;*0×104（Ea）M[R[Ea]]间接寻址（%eax）=&nbsp;*eaxImm(Ea)M[Imm+R[Ea]](基址+偏移量)寻址4(%eax)&nbsp;=&nbsp;*(4+eax)（Ea,Eb）M[R[Ea]+R[Eb]]变址(%eax,%ebx)&nbsp;=&nbsp;*(eax+ebx)Imm（Ea,Eb）M[Imm+R[Ea]+R[Eb]]寻址9(%eax,%ebx)=&nbsp;*(9+eax+ebx)(,Ea,s)M[R[Ea]*s]伸缩化变址寻址(,%eax,4)=&nbsp;*(eax*4)Imm(,Ea,s)M[Imm+R[Ea]*s]伸缩化变址寻址0xfc(,%eax,4)=&nbsp;*(0xfc+eax*4)(Ea,Eb,s)M(R[Ea]+R[Eb]*s)伸缩化变址寻址(%eax,%ebx,4)&nbsp;=&nbsp;*(eax+ebx*4)Imm(Ea,Eb,s)M(Imm+R[Ea]+R[Eb]*s)伸缩化变址寻址8(%eax,%ebx,4)&nbsp;=&nbsp;*(8+eax+ebx*4)注：M[xx]表示在存储器中xx地址的值，R[xx]表示寄存器xx的值，这种表示方法将寄存器、内存都看出一个大数组的形式。数据传送指令：指令效果描述movl&nbsp;S,DD&nbsp;&lt;–&nbsp;S传双字movw&nbsp;S,DD&nbsp;&lt;–&nbsp;S传字movb&nbsp;S,DD&nbsp;&lt;–&nbsp;S传字节movsbl&nbsp;S,DD&nbsp;&lt;–&nbsp;符号扩展S符号位填充(字节-&gt;双字)movzbl&nbsp;S,DD&nbsp;&lt;–&nbsp;零扩展S零填充(字节-&gt;双字)pushl&nbsp;SR[%esp]&nbsp;&lt;–&nbsp;R[%esp]&nbsp;–&nbsp;4;M[R[%esp]]&nbsp;&lt;–&nbsp;S压栈popl&nbsp;DD&nbsp;&lt;–&nbsp;M[R[%esp]]；R[%esp]&nbsp;&lt;–&nbsp;R[%esp]&nbsp;+&nbsp;4;出栈注：均假设栈往低地址扩展。算数和逻辑操作地址：指令效果描述leal&nbsp;S,DD&nbsp;=&nbsp;&amp;Smovl地版，S地址入D，D仅能是寄存器incl&nbsp;DD++加1decl&nbsp;DD–减1negl&nbsp;DD&nbsp;=&nbsp;-D取负notl&nbsp;DD&nbsp;=&nbsp;~D取反addl&nbsp;S,DD&nbsp;=&nbsp;D&nbsp;+&nbsp;S加subl&nbsp;S,DD&nbsp;=&nbsp;D&nbsp;–&nbsp;S减imull&nbsp;S,DD&nbsp;=&nbsp;D*S乘xorl&nbsp;S,DD&nbsp;=&nbsp;D&nbsp;^&nbsp;S异或orl&nbsp;S,DD&nbsp;=&nbsp;D&nbsp;|&nbsp;S或andl&nbsp;S,DD&nbsp;=&nbsp;D&nbsp;&amp;&nbsp;S与sall&nbsp;k,DD&nbsp;=&nbsp;D&nbsp;&lt;&lt;&nbsp;k左移shll&nbsp;k,DD&nbsp;=&nbsp;D&nbsp;&lt;&lt;&nbsp;k左移(同sall)sarl&nbsp;k,DD&nbsp;=&nbsp;D&nbsp;&gt;&gt;&nbsp;k算数右移shrl&nbsp;k,DD&nbsp;=&nbsp;D&nbsp;&gt;&gt;&nbsp;k逻辑右移特殊算术操作：指令效果描述imull&nbsp;SR[%edx]:R[%eax]&nbsp;=&nbsp;S&nbsp;*&nbsp;R[%eax]无符号64位乘mull&nbsp;SR[%edx]:R[%eax]&nbsp;=&nbsp;S&nbsp;*&nbsp;R[%eax]有符号64位乘cltd&nbsp;SR[%edx]:R[%eax]&nbsp;=&nbsp;符号位扩展R[%eax]转换为4字节idivl&nbsp;SR[%edx]&nbsp;=&nbsp;R[%edx]:R[%eax]&nbsp;%&nbsp;S;R[%eax]&nbsp;=&nbsp;R[%edx]:R[%eax]&nbsp;/&nbsp;S;有符号除法，保存余数和商divl&nbsp;SR[%edx]&nbsp;=&nbsp;R[%edx]:R[%eax]&nbsp;%&nbsp;S;R[%eax]&nbsp;=&nbsp;R[%edx]:R[%eax]&nbsp;/&nbsp;S;无符号除法，保存余数和商注：64位数通常存储为，高32位放在edx，低32位放在eax。条件码：条件码寄存器描述了最近的算数或逻辑操作的属性。CF：进位标志，最高位产生了进位，可用于检查无符号数溢出。OF：溢出标志，二进制补码溢出——正溢出或负溢出。ZF：零标志，结果为0。SF：符号标志，操作结果为负。比较指令：指令基于描述cmpb&nbsp;S2,S1S1&nbsp;–&nbsp;S2比较字节，差关系testb&nbsp;S2,S1S1&nbsp;&amp;&nbsp;S2测试字节，与关系cmpw&nbsp;S2,S1S1&nbsp;–&nbsp;S2比较字，差关系testw&nbsp;S2,S1S1&nbsp;&amp;&nbsp;S2测试字，与关系cmpl&nbsp;S2,S1S1&nbsp;–&nbsp;S2比较双字，差关系testl&nbsp;S2,S1S1&nbsp;&amp;&nbsp;S2测试双字，与关系访问条件码指令：指令同义名效果设置条件sete&nbsp;DsetzD&nbsp;=&nbsp;ZF相等/零setne&nbsp;DsetnzD&nbsp;=&nbsp;~ZF不等/非零sets&nbsp;DD&nbsp;=&nbsp;SF负数setns&nbsp;DD&nbsp;=&nbsp;~SF非负数setg&nbsp;DsetnleD&nbsp;=&nbsp;~(SF&nbsp;^OF)&nbsp;&amp;&nbsp;ZF大于（有符号&gt;）setge&nbsp;DsetnlD&nbsp;=&nbsp;~(SF&nbsp;^OF)小于等于(有符号&gt;=)setl&nbsp;DsetngeD&nbsp;=&nbsp;SF&nbsp;^&nbsp;OF小于(有符号&lt;)setle&nbsp;DsetngD&nbsp;=&nbsp;(SF&nbsp;^&nbsp;OF)&nbsp;|&nbsp;ZF小于等于(有符号&lt;=)seta&nbsp;DsetnbeD&nbsp;=&nbsp;~CF&nbsp;&amp;&nbsp;~ZF超过(无符号&gt;)setae&nbsp;DsetnbD&nbsp;=&nbsp;~CF超过或等于(无符号&gt;=)setb&nbsp;DsetnaeD&nbsp;=&nbsp;CF低于(无符号&lt;)setbe&nbsp;DsetnaD&nbsp;=&nbsp;CF&nbsp;|&nbsp;ZF低于或等于(无符号&lt;=)跳转指令：指令同义名跳转条件描述jmp&nbsp;&nbsp;&nbsp;Label1直接跳转jmp&nbsp;&nbsp;&nbsp;*Operand1间接跳转je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LabeljzZF等于/零jne&nbsp;&nbsp;&nbsp;&nbsp;Labeljnz~ZF不等/非零js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LabelSF负数jnz&nbsp;&nbsp;&nbsp;&nbsp;Label~SF非负数jg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Labeljnle~(SF^OF)&nbsp;&amp;&nbsp;~ZF大于(有符号&gt;)jge&nbsp;&nbsp;&nbsp;&nbsp;Labeljnl~(SF&nbsp;^&nbsp;OF)大于等于(有符号&gt;=)jl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LabeljngeSF&nbsp;^&nbsp;OF小于（有符号&lt;）jle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Labeljng(SF&nbsp;^&nbsp;OF)&nbsp;|&nbsp;ZF小于等于(有符号&lt;=)ja&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Labeljnbe~CF&nbsp;&amp;&nbsp;~ZF超过(无符号&gt;)jae&nbsp;&nbsp;&nbsp;&nbsp;Labeljnb~CF超过或等于(无符号&gt;=)jb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LabeljnaeCF低于(无符号&lt;)jbe&nbsp;&nbsp;&nbsp;&nbsp;LabeljnaCF&nbsp;|&nbsp;ZF低于或等于(无符号&lt;=)转移控制指令：（函数调用）：指令描述call&nbsp;&nbsp;&nbsp;&nbsp;Label过程调用，返回地址入栈，跳转到调用过程起始处，返回地址是call后面那条指令的地址call&nbsp;&nbsp;&nbsp;&nbsp;*Operandleave为返回准备好栈，为ret准备好栈，主要是弹出函数内的栈使用及%ebp</p>

</div></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_swiftype" class="widget panel panel-primary">
    
<form class="input-group">
<input type="text" id="st-search-input" class="form-control" placeholder="搜索" autocomplete="off" autocorrect="off" autocapitalize="off" style="outline: none;">
<span class="input-group-btn"><button class="btn btn-default" type="search"><i class="fa fa-search"></i></button></span>
</form></div>

<div id="widget_google_cse" class="widget panel panel-primary">
    
<gcse:searchbox-only defaultToRefinement="chenall.net" resultsUrl="/search/" newWindow="false"></gcse:searchbox-only>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">分类</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_aliyun_sidebar" class="widget panel panel-primary">
    
<div style="width:250px,height:250px" id="ali-carousel-captions" class="carousel slide" data-interval='5000' data-carousel=0 data-ride="carousel">
  <div class="carousel-inner">
        <div class="item active">
            <a href="http://s.click.taobao.com/t?e=m%3D2%26s%3Df8OlSBzu18scQipKwQzePCperVdZeJviEViQ0P1Vf2kguMN8XjClAtz4eT3bpot%2BUjTuFP33mm8byuxaD%2BeNy7E3m70uR7JIB3Dh1oz4f5NqjzRl4PJsAedn1BbglxZYxUhy8exlzcq9AmARIwX9K%2BnbtOD3UdznPV1H2z0iQv9NkKVMHClW0QbMqOpFMIvnvjQXzzpXdTHGJe8N%2FwNpGw%3D%3D"><img src="http://qiniu.chenall.net/aliyun/250x250_01.jpg"></a>      
    </div>
        <div class="item">
            <a href="http://s.click.taobao.com/t?e=m%3D2%26s%3DWx1%2FUd2Xu9scQipKwQzePCperVdZeJviEViQ0P1Vf2kguMN8XjClAgqxYtC30UH57li5%2BwaNkRMbyuxaD%2BeNy7E3m70uR7JIB3Dh1oz4f5NqjzRl4PJsAedn1BbglxZYxUhy8exlzcq9AmARIwX9Kw%2Byb%2BmDZlm0PV1H2z0iQv9eY%2By0blbhscYl7w3%2FA2kb"><img src="http://qiniu.chenall.net/aliyun/250x250_02.jpg"></a>      
    </div>
        <div class="item">
            <a href="http://s.click.taobao.com/t?e=m%3D2%26s%3DienAeqM6f0scQipKwQzePCperVdZeJviEViQ0P1Vf2kguMN8XjClAnLgecJ4ZbBLhfF8cP%2Fi%2F9obyuxaD%2BeNy7E3m70uR7JIB3Dh1oz4f5NqjzRl4PJsAedn1BbglxZYxUhy8exlzcq9AmARIwX9K2Zg%2BdzdQFOwfMRvoxSVDSdLyrb2g0H2G5JcxXijM%2BwneEHpPTskRHlFYAAV9gnNuPTL%2BS6jTvPzN7YQp05KcLcunFBf1wJnpg%3D%3D"><img src="http://qiniu.chenall.net/aliyun/d.png"></a>      
    </div>
        <div class="item">
            <a href="http://s.click.taobao.com/t?e=m%3D2%26s%3DcrAECBB8ycEcQipKwQzePCperVdZeJviEViQ0P1Vf2kguMN8XjClAuXwr7OH7D%2BIyO%2FjmuN7jksbyuxaD%2BeNy7E3m70uR7JIB3Dh1oz4f5NqjzRl4PJsAX7uq6sLYIqu0Q7QOybCaQy9AmARIwX9K9E0MBlxnM%2FDnaYpFBIfC%2F2orLd93QuCUMYOae24fhW0"><img src="http://gtms03.alicdn.com/tps/i3/TB119uIGpXXXXcaXVXXjf1M_VXX-240-180.png"></a>      
    </div>
        <div class="item">
      <a data-type="3" data-tmpl="250x250" data-tmplid="185" data-rd="2" data-style="2" data-border="1" href="#"></a>
    </div>
      </div>
  <a class="left carousel-control" href="#ali-carousel-captions" data-slide="prev"><span class="fa fa-chevron-left"></span></a>
  <a class="right carousel-control" href="#ali-carousel-captions" data-slide="next"><span class="fa fa-chevron-right"></span></a>
</div>
</div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_random_posts" class="widget panel panel-primary">
  <div class="panel-heading">随机文章</div>  <div class='hexo_random_posts' data-count=8></div></div>

<div id="widget_google_sidebar" class="widget panel panel-primary">
  <div class="panel-heading">赞助商</div>  
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-0028617410393728"
     data-ad-slot="2577551260"
     data-ad-format="rectangle"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">标签云</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_sina_weiboshow" class="widget panel panel-primary">
  <div class="panel-heading">新浪微搏秀</div>  <iframe width="100%" height="600" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=600&fansRow=0&ptype=0&speed=0&skin=5&isTitle=0&noborder=1&isWeibo=1&isFans=0&uid=1082888172&verifier=1a4946c5&dpc=1"></iframe>
</div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">最近评论</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2008-2015 chenall
  
    &nbsp;&nbsp;</span>
  <a href='http://www.miibeian.gov.cn/'>闽ICP备14002519号-1</a></span>
  <span id='analytics-51la'>
<script language="javascript" type="text/javascript" src="http://js.users.51.la/3214078.js"></script>
<noscript><a href="http://www.51.la/?3214078" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/3214078.asp" style="border:none" /></a></noscript>
</span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-30310093-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?41a3a9225fc0df0d53086baea0f90d96"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://hexo.io/'  title="本站由hexo V2.8.3 生成"><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall V2.2</a></strong><span class="pull-right"> 更新时间: <em>2015-02-18 10:40:02</em></span></div>
</div>
<div class="clearfix"></div>
  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
            <script type="text/javascript"> (function(win,doc){ var s = doc.createElement("script"), h = doc.getElementsByTagName("head")[0]; if (!win.alimamatk_show) { s.charset = "gbk"; s.async = true; s.src = "http://a.alimama.cn/tkapi.js"; h.insertBefore(s, h.firstChild); }; var o = { pid: "mm_14266497_2425855_13670245",}; win.alimamatk_onload = win.alimamatk_onload || []; win.alimamatk_onload.push(o); })(window,document);</script>    
                
            
<div id='swiftype-searchinfo' style='display: none;'><div class="alert alert-info"> 正在搜索中，稍后将在这里显示结果。。。。</div></div>
<script type="text/javascript">
var Swiftype = window.Swiftype || {key:'P473Cjp95e3bFhiCP88w',renderStyle: 'inline' };
_js2load.push({src:"//s.swiftypecdn.com/embed.js"});
$(function(){$('#main-col').prepend('<div id="st-results-container"></div>');$('form').has('#st-search-input').submit(function(){$('#st-results-container').html($('#swiftype-searchinfo').html());})});
</script>
    
            <script>_js2load.push({src:(document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=013748367689400048621:dmsqkhtcvbm'});</script>
    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"chenall"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;
      var imgsrc = /^.+?(png|bmp|jpeg)/.exec(this.src);

      $(this).wrap('<a href="' + (imgsrc?imgsrc[0]:this.src) + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />').wrap('<div class="img_block"></div>');
     
      if(alt){$(this).after('<span class="caption">' + alt + '</span>')};
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
<script src="/js/chenall.js" type="text/javascript"></script>

  <!--addons at end of body-->
</body>
</html>
