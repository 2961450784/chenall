title: "C语言的基础函数大小写转换"
id: 597
date: 2010-10-12 15:27:51
tags: 
- c语言
categories: 
- 程序设计/C
---

 在程序中经常会需要对字母的大小写进行转换，虽然有现成的upper/lower函数，但是有时因为各种原因，或想减小程序的体积，需要自己编写函数来实现。

 这里来讨论一下各种转换的方法。

根据ASCII码我们可以知道大写字母和小写字母相差32(20H)=100000B(二进制).

根据这个原理我们可以方便的进行大小写的转换。如是是大写字母+32就变成小写。

 例子: 大写字母'A' 它的ASCII码是65\. 'a'的ASCII码是97，看下面的等式。
 
 'A'+32=65+32=97 = 'a'
 
 另外:
 
 * 'a'的二进制是<font color="#FF00FF">01</font><font color="#FF6800">1</font>00001B
 * 'A'的二进制是<font color="#FF00FF">01</font><font color="#FF6800">0</font>00001B

也就是说小写和大写的区别就是100000B ，也就是bit 5的区别。

 所以还可以通过与运算修改bit 5的值也可以达到转换的目的。

把第5位置为1可以按位"或"操作，置为0 可以按位"与"操作  
 <font color="#FF00FF">00</font><font color="#FF6800">1</font>00000B = 32 = 20H  
 <font color="#FF00FF">11</font><font color="#FF6800">0</font>11111B = 223 = DFH  

'a' & 223 = 'A'    'A' | 32 = 'a'

其实也就是字母的第5位（二进制位），如果它是1就是小写的，如果是0就是大写。

另外在使用经典的代码比较时

小写转大写 >='a' 并且 <='z'  
大写转小写 >='A' 并且 <='Z'  
可以把这两个比较的顺序对换一下。  
改成<='Z' 并且 >='A' ,看起来没有什么区别，但是实际运行中效率会更高。   

 原理: 因为比较时，只要第一个条件不符合，那就不会去比较第二个条件了，利用这一点可以加快比较速度。   
 小写字母都是大于'Z'的，当然也大于'A'。  
 比如转换aBCD为小写，a已经是小写了，如果按原来的方法比较>='A' && <='Z' 需要比较两次。  
 用后面的方法只需要比较一次。  

 下面是实现的代码.有两种方式。（转大写的）
```
 void upper(char string)
{
  while(string)
  {
    #if 0
    //第一种方式比较经典的方法
      if (string >='a' && string <='z')
        string &= 0xDF;
    #else
    /*
    好像网上还没有见过这种用法，算是一个意外发现吧.
    减去'a'，如果它的值在0-25之前则它肯定是小写字母。因为是无符号数.
    如果这个字符小于a那会得到负数（>128)
    */
      if ((unsigned char)(string - 'a') < 26)
          string -= 32;
    //大写转小写只要把'a'改为'A'，转换的方式为`+= 32`或` |= 32`
    #endif
      ++string;
  }
  return;
}
```

两种不同的方式的汇编代码比较，用经典的方法执行效率可能会高一点儿。  
 用新的方法生成的文件小一点（少几个字节，在程序空间比较紧张的情况下可以用）.

![]([CDN_URL]:/upload/2010/10/1EEC7B5D67C99ACAD6F65CEB18DAD7A607AAAB5D.png)
