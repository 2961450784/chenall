title: "[转]UNICODE编码,UTF-8,UTF-16"
id: 131
date: 2010-03-09 17:02:47
tags: 
- pe
- UNICODE
- UTF-8
- 字符编码
categories: 
- 网络收集
---

<div id="PublishedByWebStory-[5]1_96F56388817743CE84FCC7D62E4B6FD1_099A88F537804FE7B93B022C1D2F3200"><div id="PublishedByWebStory-[5]1_B328F8C3382A4D51849407199493AA6C_63776D693D56411D985F4B4E7A627A21"> <div>&nbsp;</div> <div><font face="宋体">原文出处：[http://blog.sina.com.cn/s/blog_5d8cc6410100e432.html](http://blog.sina.com.cn/s/blog_5d8cc6410100e432.html)</font></div> <div>&nbsp;</div> <div><font face="宋体">第一篇：</font></div> <div><font face="宋体">═══════════════════════════════════════════════</font></div> <div><font face="宋体">Unicode(Universal Multiple-Octet Coded Character Set):
 目前最流行和最有前途的字符编码规范,因为它解决了不同语言编码的冲突。</font></div> <div>&nbsp;<wbr /></div> <div><font color="#0000FF">Uicode由来:
</font>最初的字符编码ascii(8bit,最高位为0)只能表示128个字符,表示英文、数字和一些符号是没问题。但是世界不止一种语言,即使用上了最高为1的扩展ascii码,也只有256个字符。
 对中日韩文、阿拉伯文之类复杂的文字,就无法使用了。
 于是,各国都制定了自己的兼容ascii编码规范,就是各种ANSI码,比如我国的gb2312，用两个扩展ascii字符来表示一个中文。但是这些ansi码无法同时存在,因为它们的定义互相重叠,要自由使用不同语言就必须有一个新编码,为各种文字统一分配编码。
 ISO(国际标准化组织)和Uicode协会(一个软件制造商的协会）分别开始了这个工作。即ISO的ISO 10646项目和Unicode协会的Unicode项目。后来它们开始合并了双方的工作成果，采用相同的字库和字码。但目前两个项目都存在并独立地公布自己的标准。</div> <div>&nbsp;<wbr /></div> <div><font color="#0000FF">UCS(Unicode Character Set):</font>
 这是Uicode在ISO的名称,目有两套编码方法,UCS-2(Unicode)用2个字节表示一个字符,UCS-4(Unicode-32)用4个字节表示一个字符。UCS-4是由USC-2扩展来的,增加了2字节的高位。即使是老UCS-2,它也可以表示2^16=65535个字符,基本上可以容纳所有常用各国字符,所以目前基本都使用UCS-2。</div> <div>&nbsp;<wbr /></div> <div><font color="#0000FF">UTF(UCS Transformation Format):
</font>Unicode使用2个字节表示一个字符,ascii使用1个字节,所以在很多方面产生了冲突，以前处理ascii的方法都必须重写。而且C语言用\0作为字符串结束标志,但Unicode中很多字符都含\0,C语言的字符串函数也无法正常处理Unicode。为了把unicode投入实用,出现了UTF,最常见的是UTF-8和UTF-16。
 &nbsp;<wbr />其中UTF-16和Unicode本身的编码是一致的,UTF-32和UCS-4也是相同的。最重要的是UTF-8,可以完全兼容ascii编码。UTF是一种变长的编码,它的字节数是不固定的,使用第一个字节确定字节数。第一个字节首为0即一个字节,110即2字节,1110即3字节,字符后续字节都用10开始,这样不会混淆且单字节英文字符可仍用ASCII编码。理论上UTF-8最大可以用6字节表示一个字符,但Unicode目前没有用大于0xffff的字符,实际UTF-8最多使用了3个字节。</div> <div><font face="宋体">unicode转化为UTF-8的方法
 Unicode码范围&nbsp;<wbr /> UTF-8编码(把Unicode码转为二进制填充x处)
 0000-007F&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr /> 0xxxxxxx
 0080-07FF&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr /> 110xxxxx 10xxxxxx
 0800-FFFF&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr /> 1110xxxx 10xxxxxx 10xxxxxx
 汉字的Unicode编码范围是0080-07FF,因此是2字节编码。</font></div> <div>&nbsp;<wbr /></div> <div><font color="#0000FF">Big Endian(大字节序)和Little Endian(小字节序):
</font>Unicode存储时有个字节序问题,就是一个多字节数字,是从大到小排列还是反之。这和CPU处理有关,一般x86处理时都是倒置的,即大数在前。就像“莫”字的Unicode码0x83ab,按Big Endian就变成了0xab83。</div> <div>&nbsp;<wbr /></div> <div><font color="#0000FF">BOM(Byte Order Mark):
</font>因为Unicode存储时字节序的问题,在Unicode文本前插入一个不存在的字符(ZERO WIDTH NO-BREAK SPACE)作为标志来分辨两种字节序。标志0xfeff说明按Big Endian字节序,而0xfffe说明Little-Endian。
 UTF-8不需要BOM来说明字节序，但可以用BOM标志编码方式。遇到带0xefbbbf开头的文本,计算机就可以不需要分辨直接按UTF-8编码处理。</div> <div>&nbsp;<wbr /></div> <div><font color="#0000FF">BMP(Basic Multilingual Plane):
</font>这是Unicode实际和字符对应的划分方式中的概念。
 按UCS-4为例子
 首字节首位恒为0,剩下7位可以划分2^7=128个group(组)。
 第二个字节,每个group下面可以有2^8=256个plane(平面)。
 第三个字节,可以给每个palne带来256个row(行)。
 第四个字节,这里的8位又可以每row可以划分256个cell(格子)。
 group 0中的plane 0就是BMP,即前两个字节为0x0000的UCS-4码。去掉0x0000的BMP上的UCS-4就变成了UCS-2编码。或者说UCS-2是USC-4的子集,BMP就是UCS-2在USC-4中的位置。我们从这里还可以得到USC-2转为UCS-4的方法,再UCS-2前面插入2个字节0x0000。
</div> <div>&nbsp;<wbr /></div> <div>&nbsp;<wbr /></div> <div><font face="宋体">第二篇：</font></div> <div><font face="宋体">═══════════════════════════════════════════════</font></div> <div><font face="宋体">这是一篇程序员写给程序员的趣味读物。所谓趣味是指可以比较轻松地了解一些原来不清楚的概念，增进知识，类似于打RPG游戏的升级。整理这篇文章的动机是两个问题：</font></div> <div>&nbsp;<wbr /></div> <div><font face="宋体">问题一：</font></div> <div><font face="宋体">　　使用Windows记事本的“另存为”，可以在GBK、Unicode、Unicode big endian和UTF-8这几种编码方式间相互转换。同样是txt文件，Windows是怎样识别编码方式的呢？</font></div> <div><font face="宋体">　　我很早前就发现Unicode、Unicode big endian和UTF-8编码的txt文件的开头会多出几个字节，分别是FF、FE（Unicode）,FE、FF（Unicode big endian）,EF、BB、BF（UTF-8）。但这些标记是基于什么标准呢？</font></div> <div>&nbsp;<wbr /></div> <div><font face="宋体">问题二：</font></div> <div><font face="宋体">　　最近在网上看到一个ConvertUTF.c，实现了UTF-32、UTF-16和UTF-8这三种编码方式的相互转换。对于Unicode(UCS2)、GBK、UTF-8这些编码方式，我原来就了解。但这个程序让我有些糊涂，想不起来UTF-16和UCS2有什么关系。</font></div> <div><font face="宋体">　　查了查相关资料，总算将这些问题弄清楚了，顺带也了解了一些Unicode的细节。写成一篇文章，送给有过类似疑问的朋友。本文在写作时尽量做到通俗易懂，但要求读者知道什么是字节，什么是十六进制。</font></div> <div>
 <font color="#0000FF" face="宋体">0、big endian和little endian</font></div> <div><font face="宋体">　　Big endian和Little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。</font></div> <div><font face="宋体">　　“endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。</font></div> <div><font face="宋体">　　我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。</font></div> &nbsp;<wbr /></div> <div><font color="#0000FF" face="宋体">1、字符编码、内码，顺带介绍汉字编码</font></div> <div><font face="宋体">　　字符必须编码后才能被计算机处理。计算机使用的缺省编码方式就是计算机的内码。早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。</font></div> <div><font face="宋体">　　GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。</font></div> <div><font face="宋体">　　GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。2000年的GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的PC平台必须支持GB18030，对嵌入式产品暂不作要求。所以手机、MP3一般只支持GB2312。</font></div> <div><font face="宋体">　　从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。</font></div> <div><font face="宋体">　　有的中文Windows的缺省内码还是GBK，可以通过GB18030升级包升级到GB18030。不过GB18030相对GBK增加的字符，普通人是很难用到的，通常我们还是用GBK指代中文Windows内码。</font></div> <div><font face="宋体">　　这里还有一些细节：</font></div> <div><font face="宋体">　　GB2312的原文还是区位码，从区位码到内码，需要在高字节和低字节上分别加上A0。</font></div> <div><font face="宋体">　　在DBCS中，GB内码的存储格式始终是big endian，即高位在前。</font></div> <div><font face="宋体">　　GB2312的两个字节的最高位都是1。但符合这个条件的码位只有128*128=16384个。所以GBK和GB18030的低字节最高位都可能不是1。不过这不影响DBCS字符流的解析：在读取DBCS字符流时，只要遇到高位为1的字节，就可以将下两个字节作为一个双字节编码，而不用管低字节的高位是什么。</font></div> <div>&nbsp;<wbr /></div> <div><font color="#0000FF" face="宋体">2、Unicode、UCS和UTF</font></div> <div><font face="宋体">　　前面提到从ASCII、GB2312、GBK到GB18030的编码方法是向下兼容的。而Unicode只与ASCII兼容（更准确地说，是与ISO-8859-1兼容），与GB码不兼容。例如“汉”字的Unicode编码是6C49，而GB码是BABA。</font></div> <div><font face="宋体">　　Unicode也是一种字符编码方法，不过它是由国际组织设计，可以容纳全世界所有语言文字的编码方案。Unicode的学名是"Universal Multiple-Octet Coded Character Set"，简称为UCS。UCS可以看作是"Unicode Character Set"的缩写。</font></div> <div><font face="宋体">　　根据维基百科全书(</font>[<font color="#765F47" face="宋体">http://zh.wikipedia.org/wiki/</font>](http://zh.wikipedia.org/wiki/)<font face="宋体">)的记载：历史上存在两个试图独立设计Unicode的组织，即国际标准化组织（ISO）和一个软件制造商的协会（unicode.org）。ISO开发了ISO 10646项目，Unicode协会开发了Unicode项目。</font></div> <div><font face="宋体">　　在1991年前后，双方都认识到世界不需要两个不兼容的字符集。于是它们开始合并双方的工作成果，并为创立一个单一编码表而协同工作。从Unicode2.0开始，Unicode项目采用了与ISO 10646-1相同的字库和字码。</font></div> <div><font face="宋体">　　目前两个项目仍都存在，并独立地公布各自的标准。Unicode协会现在的最新版本是2005年的Unicode 4.1.0。ISO的最新标准是10646-3:2003。</font></div> <div><font face="宋体">　　UCS规定了怎么用多个字节表示各种文字。怎样传输这些编码，是由UTF(UCS Transformation Format)规范规定的，常见的UTF规范包括UTF-8、UTF-7、UTF-16。</font></div> <div><font face="宋体">　　IETF的RFC2781和RFC3629以RFC的一贯风格，清晰、明快又不失严谨地描述了UTF-16和UTF-8的编码方法。我总是记不得IETF是Internet Engineering Task Force的缩写。但IETF负责维护的RFC是Internet上一切规范的基础。</font></div> <div>
 <font color="#0000FF" face="宋体">3、UCS-2、UCS-4、BMP</font></div> <div><font face="宋体">　　UCS有两种格式：UCS-2和UCS-4。顾名思义，UCS-2就是用两个字节编码，UCS-4就是用4个字节（实际上只用了31位，最高位必须为0）编码。下面让我们做一些简单的数学游戏：</font></div> <div><font face="宋体">　　UCS-2有2^16=65536个码位，UCS-4有2^31=2147483648个码位。</font></div> <div><font face="宋体">　　UCS-4根据最高位为0的最高字节分成2^7=128个group。每个group再根据次高字节分为256个plane。每个plane根据第3个字节分为256行 (rows)，每行包含256个cells。当然同一行的cells只是最后一个字节不同，其余都相同。</font></div> <div><font face="宋体">　　group 0的plane 0被称作Basic Multilingual Plane, 即BMP。或者说UCS-4中，高两个字节为0的码位被称作BMP。</font></div> <div><font face="宋体">　　将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。在UCS-2的两个字节前加上两个零字节，就得到了UCS-4的BMP。而目前的UCS-4规范中还没有任何字符被分配在BMP之外。</font></div> <div>&nbsp;<wbr /></div> <div><font color="#0000FF" face="宋体">4、UTF编码</font></div> <div><font face="宋体">　　UTF-8就是以8位为单元对UCS进行编码。从UCS-2到UTF-8的编码方式如下：</font></div> <div><font face="宋体">　　╔════════════╦══════════════╗
 　　║UCS-2编码(16进制)&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr /> ║UTF-8 字节流(二进制)&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr /> ║
 　　║------------------------║----------------------------║
 　　║0000 - 007F&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr /> ║0xxxxxxx&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr /> ║
 　　║0080 - 07FF&nbsp;<wbr />&nbsp;<wbr /> &nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr /> &nbsp;<wbr />║110xxxxx 10xxxxxx&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr /> &nbsp;<wbr />&nbsp;<wbr /> ║
 　　║0800 - FFFF&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr />&nbsp;<wbr /> &nbsp;<wbr /> ║1110xxxx 10xxxxxx 10xxxxxx&nbsp;<wbr /> ║
 　　╚════════════╩══════════════╝</font></div> <div>
 <font face="宋体">　　例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</font></div> <div><font face="宋体">　　读者可以用记事本测试一下我们的编码是否正确。</font></div> <div><font face="宋体">　　UTF-16以16位为单元对UCS进行编码
 。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。</font></div> <div>&nbsp;<wbr /></div> <div><font color="#0000FF" face="宋体">5、UTF的字节序和BOM</font></div> <div><font face="宋体">　　UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？</font></div> <div><font face="宋体">　　Unicode规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte Order Mark。BOM是一个有点小聪明的想法：</font></div> <div><font face="宋体">　　在UCS编码中有一个叫做"ZERO WIDTH NO-BREAK SPACE"的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符"ZERO WIDTH NO-BREAK SPACE"。</font></div> <div><font face="宋体">　　这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符"ZERO WIDTH NO-BREAK SPACE"又被称作BOM。</font></div> <div><font face="宋体">　　UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符"ZERO WIDTH NO-BREAK SPACE"的UTF-8编码是EF BB BF（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。</font></div> <div><font face="宋体">　　Windows就是使用BOM来标记文本文件的编码方式的。</font></div> <div>&nbsp;<wbr /></div> <div><font color="#0000FF" face="宋体">6、进一步的参考资料</font></div> <div><font face="宋体">　　本文主要参考的资料是 "Short overview of ISO-IEC 10646 and Unicode" (</font>[<font color="#765F47" face="宋体">http://www.nada.kth.se/i18n/ucs/unicode-iso10646-oview.html</font>](http://www.nada.kth.se/i18n/ucs/unicode-iso10646-oview.html)<font face="宋体">)。</font></div> <div><font face="宋体">　　我还找了两篇看上去不错的资料，不过因为我开始的疑问都找到了答案，所以就没有看：</font></div> <div><font face="宋体">"Understanding Unicode A general introduction to the Unicode Standard" (</font>[<font color="#765F47" face="宋体">http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;item_id=IWS-Chapter04a</font>](http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;item_id=IWS-Chapter04a)<font face="宋体">)
 "Character set encoding basics Understanding character set encodings and legacy encodings" (</font>[<font color="#765F47" face="宋体">http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;item_id=IWS-Chapter03</font>](http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;item_id=IWS-Chapter03)<font face="宋体">)</font></div> 

&nbsp;

</div>